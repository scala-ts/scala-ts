// Generated by ScalaTS 0.7.0-SNAPSHOT: https://scala-ts.github.io/scala-ts/
import * as idtlt from 'idonttrustlikethat';
export const _externalDependencyModules = [idtlt];

declare var exports: any;

export const nsCategory = exports;

import * as nsIpsum from './Ipsum';
import * as nsLorem from './Lorem';

export const dependencyModules = [
  nsIpsum,
  nsLorem,
];

// Validator for UnionDeclaration CategoryUnion
export const idtltCategoryUnion = idtlt.union(
  nsIpsum.idtltDiscriminatedIpsum,
  nsLorem.idtltDiscriminatedLorem);

// Deriving TypeScript type from CategoryUnion validator
export type CategoryUnion = typeof idtltCategoryUnion.T;

export const idtltDiscriminatedCategoryUnion = idtlt.intersection(
  idtltCategoryUnion,
  idtlt.object({
    _type: idtlt.literal('CategoryUnion')
  })
);

// Deriving TypeScript type from idtltDiscriminatedCategoryUnion validator
export type DiscriminatedCategoryUnion = typeof idtltDiscriminatedCategoryUnion.T;

export const CategoryUnionValues = {
  Ipsum: nsIpsum.IpsumInhabitant, 
  Lorem: nsLorem.LoremInhabitant
} as const;

export type CategoryUnionValuesKey = keyof typeof CategoryUnionValues;

// Aliases for the Union utilities
export const CategoryValues = CategoryUnionValues;

export type CategoryValuesKey = CategoryUnionValuesKey;

export function mapCategoryUnionValues<T>(f: (_k: CategoryUnionValuesKey) => T): Readonly<Record<CategoryUnionValuesKey, T>> {
  return {
    Ipsum: f(nsIpsum.IpsumInhabitant), 
    Lorem: f(nsLorem.LoremInhabitant)
  }
}

export function mapCategoryValues<T>(f: (_k: CategoryValuesKey) => T): Readonly<Record<CategoryValuesKey, T>> {
  return mapCategoryUnionValues<T>(f);
}

export const CategoryUnionTypes = {
  Ipsum: nsIpsum.IpsumInhabitant, 
  Lorem: nsLorem.LoremInhabitant
} as const;

export const CategoryUnion = {
  ...CategoryUnionValues,
  ...CategoryUnionTypes
} as const;

export const idtltCategoryUnionKnownValues: ReadonlySet<CategoryUnion> = new Set<CategoryUnion>(Object.values(CategoryUnion) as ReadonlyArray<CategoryUnion>);

export function isCategoryUnion(v: any): v is CategoryUnion {
  return (
    nsIpsum.isIpsum(v) ||
    nsLorem.isLorem(v)
  );
}

export const idtltCategoryKnownValues: ReadonlySet<Category> =
  idtltCategoryUnionKnownValues;

export const Category = CategoryUnion;

export class CategorySingleton {
  public readonly Lorem: nsLorem.LoremSingleton = nsLorem.LoremInhabitant;

  public readonly Ipsum: nsIpsum.IpsumSingleton = nsIpsum.IpsumInhabitant;

  private static instance: CategorySingleton;

  private constructor() {}

  public static getInstance() {
    if (!CategorySingleton.instance) {
      CategorySingleton.instance = new CategorySingleton();
    }

    return CategorySingleton.instance;
  }
}

export const CategorySingletonInhabitant: CategorySingleton = CategorySingleton.getInstance();

export function isCategorySingleton(v: any): v is CategorySingleton {
  return (v instanceof CategorySingleton) && (v === CategorySingletonInhabitant);
}

export const idtltCategorySingleton =
  idtlt.unknown.and(_unknown => idtlt.Err(
    'Cannot validator instance for singleton CategorySingleton'));

export const CategoryInhabitant = CategorySingletonInhabitant;


// Validator for CompositeDeclaration Category
export const idtltCategory = idtltCategoryUnion;

export function isCategory(v: any): v is Category {
  return isCategoryUnion(v);
}

// Deriving TypeScript type from Category validator
export type Category = typeof idtltCategory.T;

export const idtltDiscriminatedCategory = idtlt.intersection(
  idtltCategory,
  idtlt.object({
    _type: idtlt.literal('Category')
  })
);

// Deriving TypeScript type from idtltDiscriminatedCategory validator
export type DiscriminatedCategory = typeof idtltDiscriminatedCategory.T;

// Workaround for local type references in the same module
type privateCategory = Category;

namespace nsCategory {
  export type Category = privateCategory;
}
