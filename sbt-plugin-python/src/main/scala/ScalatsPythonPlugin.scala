package io.github.scalats.sbt.python

import sbt._
import sbt.Keys._

import _root_.io.github.scalats.python.{
  PythonDeclarationMapper,
  PythonFilePrinter,
  PythonTypeMapper
}
import _root_.io.github.scalats.sbt.ScalatsGeneratorPlugin

object ScalatsPythonPlugin extends AutoPlugin {
  override def requires = ScalatsGeneratorPlugin
  override def trigger = noTrigger

  object autoImport {

    val scalatsPythonBaseModule =
      settingKey[Option[String]]("Optional Python base module")

  }

  import ScalatsGeneratorPlugin.autoImport._
  import Manifest.version
  import autoImport._

  override lazy val projectSettings: Seq[Def.Setting[_]] =
    scalatsAddScalatsDependency(
      Manifest.groupId %% "scala-ts-python" % Manifest.version
    ) ++ Seq(
      scalatsPythonBaseModule := Option.empty[String],
      Compile / scalacOptions += {
        val baseMod = scalatsPythonBaseModule.value.mkString

        s"-P:scalats:sys.scala-ts.printer.python-base-module=${baseMod}"
      },
      scalatsPrinter := scalatsPrinterForClass[PythonFilePrinter](),
      scalatsIndent := "    ",
      scalatsLineSeparator := "",
      scalatsPrinterPrelude := scalatsPrinterInMemoryPrelude(
        s"# Generated by ScalaTS ${version}: https://scala-ts.github.io/scala-ts/"
      ),
      scalatsImportResolvers += scalatsUnionWithLiteralSingletonImportResolvers,
      scalatsTypeMappers := Seq(
        // Custom type mapper
        classOf[PythonTypeMapper]
      ),
      scalatsDeclarationMappers := Seq(
        // Custom declaration mapper (before type mapper)
        classOf[PythonDeclarationMapper]
      ),
      scalatsAdditionalClasspath ++= {
        classOf[PythonDeclarationMapper].getClassLoader match {
          case cls: java.net.URLClassLoader =>
            cls.getURLs.toSeq.flatMap { url =>
              val repr = url.toString

              if (
                repr.indexOf("sbt-scala-ts-python") != -1 &&
                repr.startsWith("file:")
              ) {
                Seq(new File(url.toURI))
              } else {
                Seq.empty[File]
              }
            }

          case _ =>
            Seq.empty[File]
        }
      }
    )
}
